The most important component in the execution of a program is EIP register, aka. Extended Instruction Point. A register that is meant (at all times) to point at the next instruction to be executed. 

In other word, if you wanted control over any program you would want to control that. 

The EIP is a necessity of the [[Generics on Machine Architecture|Machine Architecture]]. Programs work using two fundamental components the Processor(CPU) and Memory(RAM). Memory stores data and operation to perform on this data as binary information, thus technically from a representational level, data and operation are written using the same language and it is the processor which says what part of the memory is code what is data. Namely, anything that the EIP points to will be interpreted as code.

The default working of the EIP is that, it starts by pointing at an address we call the Entry Point (EP) and then increments at each step. This is the cause behind the sequential aspect of code. 

To do more sophisticated things we have two types of instructions that control where the EIP points at, (1) jump instructions which are behind most decision control structures like conditionals and loops; these change directly the EIP. (2) call instruction which is just a more complicated version of jump used to make functions possible; the instruction after loading arguments and allocate space for local variables on the stack will jump to the zone of the moment where our function is located, execute its content then return using the address-pointing to what is after the function call- to the main context.

The first type of instructions cannot be controlled from a user perspective unless you alter the executable directly (a reverse engineering job). The second type offers a way to exploitation as arguments are something that could be related to user inputs.

A stack overflow exploit inputs a payload that will overflow the stack to override the normal return address to the address we desire.